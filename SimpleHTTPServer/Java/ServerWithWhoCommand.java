import java.net.*;
import java.io.*;

/***********************************************************************************************
 * 
 * A very simple HTTP server that can has some special commands (who and exit)
 * built in
 * 
 ***********************************************************************************************/
public class ServerWithWhoCommand {

    public static void send404(PrintStream out, String toPrint) {
        out.println("HTTP/1.1 404 Not Found");
        out.println("Content-Type: text/html");
        out.println("Content-Length: " + toPrint.length());
        out.println("Connection: close");
        out.println("");
        out.println(toPrint);
    }

    /*
     * Run the "who" command, and format the results as a text document.
     * (The "who" command is standard on Unix-like systems.)
     */
    public static void sendWhoText(PrintStream out) {

        String toPrint = Who.whoText();

        out.println("HTTP/1.1 200 OK");
        out.println("Content-Type: text/plain");
        out.println("Content-Length: " + toPrint.length());
        out.println("Connection: close");
        out.println("");
        out.println(toPrint);
    }

    /*
     * Run the "who" command, and format the results as an HTML document.
     * (The "who" command is standard on Unix-like systems.)
     */
    public static void sendWhoHTML(PrintStream out) {

        // The dynamic content is generated by code in the Who class
        String toPrint = Who.whoHTML();

        out.println("HTTP/1.1 200 OK");
        out.println("Content-Type: text/html");
        out.println("Content-Length: " + toPrint.length());
        out.println("Connection: close");
        out.println("");
        out.println(toPrint);
    }

    // The dynamic content is generated by code in the Who class
    public static void main(String[] args) throws IOException {

        // Create a socket that listens on port 8534.
        int port = 8534;
        ServerSocket serverSocket = new ServerSocket(port);

        // Handle multiple requests sequentially
        while (true) {
            System.out.println("\n\nAwaiting new connection on port " + port);

            // Return a Socket object for the next connection in the queue
            Socket socket = serverSocket.accept();

            // Created a BufferedReader that can read from the socket
            BufferedReader input = new BufferedReader(new InputStreamReader(socket.getInputStream()));

            // Create a PrintStream than can write to the socket
            // Passing "true" as the second parameter causes each write to be followed by a
            // flush.
            PrintStream out = new PrintStream(socket.getOutputStream(), true);

            // Read the main command.
            String command = input.readLine();
            System.out.println("Command Received: =>" + command + "<=");

            // Read the request headers
            System.out.println("\nRequest Headers:");
            String headerLine = input.readLine();
            while (headerLine != null && !headerLine.isEmpty()) {
                System.out.println("\t" + headerLine);
                headerLine = input.readLine();
            }

            // split the command by spaces.
            String[] parts = command.split("\\s+");
            System.out.printf("Command; %s; path %s; protocol %s\n", parts[0], parts[1], parts[2]);

            String filename = parts[1];
            System.out.println("Filenamae: =>" + filename + "<=");
            //
            // NEW CODE GOES HERE
            //

            // exit the server if the user requests "exit"
            if (filename.equals("/exit")) {
                // Obviously, this is a bad idea for a "real" server
                socket.close();
                break;
            } else if (filename.equals("/whoText")) {
                sendWhoText(out);
                socket.close();
                continue;
            } else if (filename.equals("/who")) {
                sendWhoHTML(out);
                socket.close();
                continue;
            }

            // If the path begins with "/", remove the "/".
            if (filename.startsWith("/")) {
                filename = filename.substring(1);
            }

            File f = new File(filename);

            // send 404 if file doesn't exist, or is not readable.
            if (!f.exists() || !f.canRead() || !f.isFile()) {
                System.out.println(filename + " not found.  Returning 404.");
                String toPrint = "<html><body>Problem finding/reading \"" + filename + "\"</body></html>";
                send404(out, toPrint);
                socket.close();
                continue;
            }

            FileInputStream fis;

            try {
                fis = new FileInputStream(f);
            } catch (Exception e) {
                String toPrint = "<html><body>Problem opening/reading \"" + filename + "\"</body></html>";
                send404(out, toPrint);
                socket.close();
                break;
            }

            // Respond
            out.println("HTTP/1.1 200 OK");
            out.println("Content-Type: text/html");
            out.println("Content-Length: " + f.length());
            out.println("Connection: close");
            out.println("");

            // read data from the file and send it to the client.
            byte[] buffer = new byte[8192];
            int read = fis.read(buffer);
            while (read != -1) {
                out.write(buffer, 0, read);
                read = fis.read(buffer);
            }
            fis.close();

            socket.close();

        } // end while(true)

        serverSocket.close();

        // When the connection ends, so does this program.
    }
}
